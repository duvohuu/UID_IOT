\chapter{MAIN SERVER}
    \section{CONTROLLERS}
        \hspace*{0.6cm}Là nơi chứa logic xử lý cho các endpoint API, thuộc tầng Controller (MVC) hoặc Application Layer (Layered Architecture). Có chức năng:
        \begin{itemize}
            \item Xử lý logic nghiệp vụ: Các hàm trong controller (như loginUser, getDevices) xử lý yêu cầu từ Front-end, gọi API của dbServer để lấy dữ liệu, và trả kết quả.
            \item Điều phối giữa Route và Model: Kết nối các route (trong routes/) với dữ liệu từ dbServer.
        \end{itemize}
        \subsection{deviceController}
            \hspace*{0.6cm}Chứa các hàm xử lý liên quan đến thiết bị, như thêm, sửa, xóa thiết bị. Các hàm này sẽ gọi API của dbServer để thực hiện các thao tác trên cơ sở dữ liệu.
            \subsubsection{Import}
                \hspace*{0.6cm}Thư viện được nhập:
                \begin{lstlisting}
    import axios from "axios";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{axios}: Thư viện để gửi yêu cầu HTTP tới server cơ sở dữ liệu.
                \end{itemize}

            \subsubsection{Biến URL}
                \hspace*{0.6cm}Định nghĩa URL server cơ sở dữ liệu:
                \begin{lstlisting}
                const DB_SERVER_URL = process.env.DB_SERVER_URL || "http://localhost:5001";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{DB\_SERVER\_URL}: Lấy từ biến môi trường hoặc mặc định \texttt{http://localhost:5001}.
                \end{itemize}

            \subsubsection{Hàm getDevices}
                \hspace*{0.6cm}Hàm xử lý yêu cầu lấy danh sách thiết bị:
                \begin{lstlisting}
    export const getDevices = async (req, res) => {
        try {
            const response = await axios.get(`${DB_SERVER_URL}/db/devices`);
            res.json(response.data);
        } catch (error) {
            res.status(500).json({ message: "Error fetching device list" });
        }
    };
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{req}, \texttt{res}: Tham số yêu cầu và phản hồi từ framework như Express.js.
                    \item Gửi yêu cầu GET tới \texttt{/db/devices} trên \texttt{DB\_SERVER\_URL}.
                    \item Nếu thành công:
                    \begin{itemize}
                        \item Trả về dữ liệu JSON từ phản hồi của server (\texttt{response.data}).
                    \end{itemize}
                    \item Nếu thất bại:
                    \begin{itemize}
                        \item Trả về mã trạng thái 500 và thông báo lỗi \texttt{\{ message: "Error fetching device list" \}}.
                    \end{itemize}
                \end{itemize}

            \subsubsection{Export}
                \hspace*{0.6cm}Hàm được xuất:
                \begin{lstlisting}
    export default getDevices;
                \end{lstlisting}
                \begin{itemize}
                    \item Xuất hàm để sử dụng trong các tuyến API của ứng dụng Node.js.
                \end{itemize}

            \subsubsection{Chức Năng Chính}
                \begin{itemize}
                    \item \textbf{Lấy Danh Sách Thiết Bị}: Sử dụng \texttt{axios} để gửi yêu cầu GET tới endpoint \texttt{/db/devices} trên server cơ sở dữ liệu.
                    \item \textbf{Xử Lý Phản Hồi}: Trả về danh sách thiết bị dưới dạng JSON nếu thành công, hoặc thông báo lỗi nếu thất bại.
                    \item \textbf{Xử Lý Lỗi}: Trả về mã trạng thái 500 và thông báo lỗi khi không thể lấy dữ liệu.
                    \item \textbf{Tích Hợp API}: Được thiết kế để sử dụng trong các tuyến API, tương thích với Express.js.
                \end{itemize}
        \subsubsection{userController}
            \hspace*{0.6cm}Các hàm API \texttt{registerUser}, \texttt{loginUser}, \texttt{logoutUser}, \texttt{updateAvatar}, \texttt{changePassword}, cùng các hàm hỗ trợ, là các hàm xử lý yêu cầu liên quan đến quản lý người dùng trong ứng dụng Node.js. Sử dụng \texttt{axios} để giao tiếp với server cơ sở dữ liệu, \texttt{jwt} để tạo token xác thực, và \texttt{fs} để quản lý tệp avatar, các hàm này cung cấp các chức năng đăng ký, đăng nhập, đăng xuất, cập nhật avatar và đổi mật khẩu. Báo cáo này phân tích chi tiết mã nguồn, chức năng và thiết kế của các hàm. 
            \subsection{Import}
                \hspace*{0.6cm}Các thư viện được nhập:
                \begin{lstlisting}
    import axios from "axios";
    import jwt from "jsonwebtoken";
    import fs from "fs";
    import path from "path";
    import { fileURLToPath } from "url";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{axios}: Gửi yêu cầu HTTP tới server cơ sở dữ liệu.
                    \item \texttt{jwt}: Tạo và xác minh JSON Web Token cho xác thực.
                    \item \texttt{fs}: Quản lý hệ thống tệp (tệp avatar).
                    \item \texttt{path}: Xử lý đường dẫn tệp.
                    \item \texttt{fileURLToPath}: Chuyển URL mô-đun ES thành đường dẫn tệp.
                \end{itemize}

            \subsubsection{Biến và Hằng}
                \hspace*{0.6cm}Định nghĩa URL và đường dẫn:
                \begin{lstlisting}
    const DB_SERVER_URL = process.env.DB_SERVER_URL || "http://localhost:5001";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{DB\_SERVER\_URL}: URL server cơ sở dữ liệu, mặc định \texttt{http://localhost:5001}.
                    \item \texttt{\_\_filename}, \texttt{\_\_dirname}: Đường dẫn tệp hiện tại, hỗ trợ mô-đun ES.
                \end{itemize}

            \subsubsection{Hàm Kiểm Tra Đầu Vào}
                \hspace*{0.6cm}Các hàm kiểm tra dữ liệu đầu vào:
                \begin{lstlisting}
    const isValidEmail = (email) => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    };

    const validateRegisterInput = (username, email, password) => {
        if (!username || username.length < 3) {
            return "Username must be at least 3 characters";
        }
        if (!email || !isValidEmail(email)) {
            return "Invalid email";
        }
        if (!password || password.length < 6) {
            return "Password must be at least 6 characters";
        }
        return null;
    };

    const validateLoginInput = (email, password) => {
        if (!email || !isValidEmail(email)) {
            return "Invalid email";
        }
        if (!password || password.length < 6) {
            return "Password must be at least 6 characters";
        }
        return null;
    };

    const validateChangePasswordInput = (oldPassword, newPassword) => {
        if (!oldPassword || oldPassword.length < 6) {
            return "Password must be at least 6 characters";
        }
        if (!newPassword || newPassword.length < 6) {
            return "Password must be at least 6 characters";
        }
        if (oldPassword === newPassword) {
            return "New password must differ from old password";
        }
        return null;
    };
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{isValidEmail}: Kiểm tra định dạng email bằng regex.
                    \item \texttt{validateRegisterInput}: Kiểm tra \texttt{username} (ít nhất 3 ký tự, sử dụng $\geq 3$), \texttt{email} (hợp lệ), \texttt{password} (ít nhất 6 ký tự, sử dụng $\geq 6$).
                    \item \texttt{validateLoginInput}: Kiểm tra \texttt{email} (hợp lệ), \texttt{password} (ít nhất 6 ký tự, sử dụng $\geq 6$).
                    \item \texttt{validateChangePasswordInput}: Kiểm tra \texttt{oldPassword}, \texttt{newPassword} (ít nhất 6 ký tự, sử dụng $\geq 6$, và khác nhau).
                \end{itemize}

            \subsubsection{Hàm registerUser}
                \hspace*{0.6cm}Hàm đăng ký người dùng:
                \begin{lstlisting}
export const registerUser = async (req, res) => {
    const { username, email, password } = req.body;
    try {
        const validationError = validateRegisterInput(username, email, password);
        if (validationError) {
            return res.status(400).json({ message: validationError });
        }

        const response = await axios.get(`${DB_SERVER_URL}/db/users/email/${email}`);
        if (response.status === 200) {
            return res.status(400).json({ message: "Email already exists" });
        }

        const newUser = await axios.post(`${DB_SERVER_URL}/db/users`, { username, email, password });
        res.status(201).json({ message: "Registration successful" });
    } catch (err) {
        if (err.response && err.response.status === 404) {
            try {
                await axios.post(`${DB_SERVER_URL}/db/users`, { username, email, password });
                res.status(201).json({ message: "Registration successful" });
            } catch (createErr) {
                res.status(500).json({ message: "Error registering user" });
            }
        } else {
            res.status(500).json({ message: "Error registering user" });
        }
    }
};
            \end{lstlisting}
                \begin{itemize}
                    \item Kiểm tra đầu vào với \texttt{validateRegisterInput}.
                    \item Kiểm tra email tồn tại bằng GET \texttt{/db/users/email/:email}.
                    \item Nếu email đã tồn tại, trả về lỗi 400.
                    \item Nếu email không tồn tại (404), tạo người dùng mới bằng POST \texttt{/db/users}.
                    \item Trả về thông báo thành công (201) hoặc lỗi (500).
                \end{itemize}

            \subsubsection{Hàm loginUser}
                \hspace*{0.6cm}Hàm đăng nhập người dùng:
                \begin{lstlisting}
export const loginUser = async (req, res) => {
    const { email, password } = req.body;
    try {
        const validationError = validateLoginInput(email, password);
        if (validationError) {
            console.log("Validation error:", validationError);
            return res.status(400).json({ message: validationError });
        }

        console.log("Logging in:", email);
        const response = await axios.get(`${DB_SERVER_URL}/db/users/email/${email}`);
        const user = response.data;

        console.log("User found:", user.email);
        const isMatch = await bcryptCompare(password, user.password);
        if (!isMatch) {
            console.log("Incorrect password for:", email);
            return res.status(401).json({ message: "Invalid login credentials" });
        }

        console.log("Login successful, generating token...");
        const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: "1d" });
        res.cookie("authToken", token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === "production",
            sameSite: "lax",
            maxAge: 24 * 60 * 60 * 1000,
        });
        res.json({ username: user.username, avatar: user.avatar });
    } catch (err) {
        if (err.response && err.response.status === 404) {
            console.log("User not found:", email);
            return res.status(401).json({ message: "Invalid login credentials" });
        }
        console.error("Login error:", err.message);
        res.status(500).json({ message: "Login error" });
    }
};
                \end{lstlisting}
                \begin{itemize}
                    \item Kiểm tra đầu vào với \texttt{validateLoginInput}.
                    \item Tìm người dùng bằng GET \texttt{/db/users/email/:email}.
                    \item So sánh mật khẩu với \texttt{bcryptCompare} (yêu cầu \texttt{bcryptjs}).
                    \item Nếu mật khẩu khớp, tạo JWT và lưu vào cookie \texttt{authToken}.
                    \item Trả về \texttt{username} và \texttt{avatar}, hoặc lỗi nếu thất bại.
                \end{itemize}

            \subsubsection{Hàm logoutUser}
                \hspace*{0.6cm}Hàm đăng xuất người dùng:
                \begin{lstlisting}
                export const logoutUser = async (req, res) => {
                    res.clearCookie("authToken");
                    res.json({ message: "Logout successful" });
                };
                \end{lstlisting}
                \begin{itemize}
                    \item Xóa cookie \texttt{authToken}.
                    \item Trả về thông báo thành công.
                \end{itemize}

            \subsubsection{Hàm updateAvatar}
                \hspace*{0.6cm}Hàm cập nhật avatar:
                \begin{lstlisting}
export const updateAvatar = async (req, res) => {
    try {
        const userId = req.user.id;
        console.log("User ID:", userId);
        const response = await axios.get(`${DB_SERVER_URL}/db/users/${userId}`);
        const user = response.data;

        if (!req.file) {
            console.log("No file uploaded");
            return res.status(400).json({ message: "No file uploaded" });
        }

        console.log("File uploaded:", req.file);

        const uploadDir = path.join(__dirname, "../upload/avatars");
        if (!uploadDir) {
            console.log("Creating upload/avatars directory");
            fs.mkdirSync(uploadDir, { recursive: true });
        }

        if (user.avatar) {
            const oldAvatarFilename = path.basename(user.avatar);
            const oldAvatarPath = path.join(uploadDir, oldAvatarFilename);
            try {
                if (fs.existsSync(oldAvatarPath)) {
                    console.log(`Deleting old avatar file: ${oldAvatarPath}`);
                    fs.unlinkSync(oldAvatarPath);
                } else {
                    console.log(`Old avatar file not found: ${oldAvatarPath}`);
                }
            } catch (err) {
                console.error("Error deleting old avatar file:", err.message);
            }
        }

        const avatarPath = `/avatars/${req.file.filename}`;
        await axios.put(`${DB_SERVER_URL}/db/users/${userId}`, { avatar: avatarPath });
        console.log("Updated avatar in database:", avatarPath);

        res.json({ avatar: avatarPath });
    } catch (err) {
        console.error("Error updating avatar:", err.message);
        if (req.file) {
            const newAvatarPath = path.join(__dirname, "../upload/avatars", req.file.filename);
            try {
                if (fs.existsSync(newAvatarPath)) {
                    console.log(`Deleting new file due to error: ${newAvatarPath}`);
                    fs.unlinkSync(newAvatarPath);
                }
            } catch (err) {
                console.error("Error deleting new file:", err.message);
            }
        }
        res.status(500).json({ message: err.message || "Error updating avatar" });
    }
};
                \end{lstlisting}
                \begin{itemize}
                    \item Lấy \texttt{userId} từ \texttt{req.user.id} (giả định middleware xác thực).
                    \item Kiểm tra và tạo thư mục \texttt{upload/avatars} nếu chưa tồn tại.
                    \item Xóa avatar cũ nếu có.
                    \item Lưu đường dẫn avatar mới và cập nhật trong cơ sở dữ liệu bằng PUT \texttt{/db/users/:id}.
                    \item Nếu lỗi, xóa tệp mới tải lên và trả về thông báo lỗi.
                \end{itemize}

            \subsubsection{Hàm changePassword}
                \hspace*{0.6cm}Hàm đổi mật khẩu:
                \begin{lstlisting}
export const changePassword = async (req, res) => {
    const { oldPassword, newPassword } = req.body;
    try {
        const validationError = validateChangePasswordInput(oldPassword, newPassword);
        if (validationError) {
            return res.status(400).json({ message: validationError });
        }

        const userId = req.user.id;
        const response = await axios.get(`${DB_SERVER_URL}/db/users/${userId}`);
        const user = response.data;

        const isMatch = await bcryptCompare(oldPassword, user.password);
        if (!isMatch) {
            return res.status(401).json({ message: "Incorrect old password" });
        }

        await axios.put(`${DB_SERVER_URL}/db/users/${userId}`, { password: newPassword });

        res.json({ message: "Password change successful" });
    } catch (err) {
        console.error("Error changing password:", err.message);
        res.status(500).json({ message: "Error changing password" });
    }
};
                \end{lstlisting}
                \begin{itemize}
                    \item Kiểm tra đầu vào với \texttt{validateChangePasswordInput}.
                    \item So sánh \texttt{oldPassword} với mật khẩu hiện tại bằng \texttt{bcryptCompare}.
                    \item Cập nhật mật khẩu mới bằng PUT \texttt{/db/users/:id}.
                    \item Trả về thông báo thành công hoặc lỗi.
                \end{itemize}

            \subsubsection{Hàm bcryptCompare}
                \hspace*{0.6cm}Hàm so sánh mật khẩu:
                \begin{lstlisting}
    const bcryptCompare = async (plainPassword, hashedPassword) => {
        const bcrypt = await import("bcryptjs");
        return await bcrypt.compare(plainPassword, hashedPassword);
    };
                \end{lstlisting}
                \begin{itemize}
                    \item Tạm thời nhập \texttt{bcryptjs} và so sánh mật khẩu, yêu cầu cài đặt \texttt{bcryptjs} trên server chính.
                \end{itemize}

            \subsubsection{Chức Năng Chính}
                \begin{itemize}
                    \item \textbf{Đăng Ký Người Dùng}: Kiểm tra đầu vào, kiểm tra email tồn tại, tạo người dùng mới.
                    \item \textbf{Đăng Nhập Người Dùng}: Kiểm tra thông tin đăng nhập, tạo JWT, lưu cookie xác thực.
                    \item \textbf{Đăng Xuất Người Dùng}: Xóa cookie xác thực.
                    \item \textbf{Cập Nhật Avatar}: Xóa avatar cũ, lưu avatar mới, cập nhật cơ sở dữ liệu.
                    \item \textbf{Đổi Mật Khẩu}: Kiểm tra mật khẩu cũ, cập nhật mật khẩu mới.
                    \item \textbf{Kiểm Tra Đầu Vào}: Đảm bảo dữ liệu hợp lệ cho đăng ký, đăng nhập, đổi mật khẩu.
                \end{itemize}
    \section{ROUTES}
        \hspace*{0.6cm}Là nơi định tuyến yêu cầu từ Front-end đến controller, thuộc tầng Controller (MVC) hoặc Application Layer (Layered Architecture). Có chức năng:
        \begin{itemize}
            \item Định nghĩa endpoint API: Xác định các URL (như /api/users/login, /api/devices) và phương thức HTTP (GET, POST, v.v.).
            \item Điều phối yêu cầu: Chuyển yêu cầu từ Front-end đến các hàm xử lý trong controllers/ (như loginUser, getDevices).
            \item Áp dụng middleware: Thêm các middleware (như authenticateToken, upload) trước khi gọi controller.
        \end{itemize}
        \subsection{deviceRoute}
            \hspace*{0.6cm}Xác định endpoint như GET /api/devices để lấy danh sách thiết bị, gọi hàm getDevices trong deviceController.js và sử dụng authenticateToken để kiểm tra token trước khi xử lý
            \subsubsection{Import}
                \hspace*{0.6cm}Các thư viện và thành phần được nhập:
                \begin{lstlisting}
    import express from "express";
    import { getDevices } from "../controllers/deviceController.js";
    import { authenticateToken } from "../middleware/auth.js";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{express}: Framework để tạo router và xử lý yêu cầu HTTP.
                    \item \texttt{getDevices}: Hàm xử lý từ \texttt{deviceController} để lấy danh sách thiết bị.
                    \item \texttt{authenticateToken}: Middleware xác thực token từ \texttt{auth}.
                \end{itemize}

            \subsubsection{Định Nghĩa Router}
                \hspace*{0.6cm}Tạo một router Express:
                \begin{lstlisting}
                const router = express.Router();
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{router}: Một instance của \texttt{express.Router} để định nghĩa các tuyến API.
                \end{itemize}

            \subsubsection{Tuyến API}
                \hspace*{0.6cm}Định nghĩa tuyến GET:
                \begin{lstlisting}
    router.get("/", authenticateToken, getDevices);
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{router.get("/")}: Định nghĩa tuyến GET cho đường dẫn gốc (\texttt{/}).
                    \item \texttt{authenticateToken}: Middleware kiểm tra token xác thực trước khi xử lý yêu cầu.
                    \item \texttt{getDevices}: Hàm xử lý trả về danh sách thiết bị.
                \end{itemize}
            \subsubsection{Export}
                \hspace*{0.6cm}Xuất router để sử dụng trong ứng dụng:
                \begin{lstlisting}
    export default router;
                \end{lstlisting}
                \begin{itemize}
                    \item Xuất \texttt{router} để tích hợp vào ứng dụng Express chính.
                \end{itemize}

            \subsubsection{Chức Năng Chính}
                \hspace*{0.6cm}Tệp định tuyến cung cấp một tuyến API để lấy danh sách thiết bị:
                \begin{itemize}
                    \item \textbf{Định Tuyến Yêu Cầu}: Xử lý yêu cầu GET tại \texttt{/} để trả về danh sách thiết bị.
                    \item \textbf{Xác Thực Yêu Cầu}: Sử dụng middleware \texttt{authenticateToken} để đảm bảo chỉ người dùng đã đăng nhập mới truy cập được.
                    \item \textbf{Tích Hợp Hàm Xử Lý}: Gọi \texttt{getDevices} để lấy dữ liệu từ server cơ sở dữ liệu.
                    \item \textbf{Thiết Kế Mô-đun}: Sử dụng \texttt{express.Router} để tổ chức tuyến API một cách độc lập, dễ bảo trì.
                \end{itemize}
        \subsection{userRoute}
            \hspace*{0.6cm}Tệp định nghĩa route cho người dùng: Xác định các endpoint như POST /api/users/login, POST /api/users/register, POST /api/users/change-password...Gọi các hàm như loginUser, registerUser, changePassword trong usersController.js và sử dụng authenticateToken (xác thực token) hoặc upload (xử lý file upload) cho một số route.
            \subsubsection{Import}
                \hspace*{0.6cm}Các thư viện và thành phần được nhập:
                \begin{lstlisting}
    import express from "express";
    import { registerUser, loginUser, logoutUser, updateAvatar, changePassword } from "../controllers/usersController.js";
    import { authenticateToken } from "../middleware/auth.js";
    import upload from "../middleware/upload.js";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{express}: Framework để tạo router và xử lý yêu cầu HTTP.
                    \item \texttt{registerUser}, \texttt{loginUser}, \texttt{logoutUser}, \texttt{updateAvatar}, \texttt{changePassword}: Các hàm xử lý từ \texttt{usersController}.
                    \item \texttt{authenticateToken}: Middleware xác thực token từ \texttt{auth}.
                    \item \texttt{upload}: Middleware xử lý tải tệp từ \texttt{upload}.
                \end{itemize}

            \subsubsection{Định Nghĩa Router}
                \hspace*{0.6cm}Tạo một router Express:
                \begin{lstlisting}
    const router = express.Router();
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{router}: Một instance của \texttt{express.Router} để định nghĩa các tuyến API.
                \end{itemize}

            \subsubsection{Tuyến API}
                \hspace*{0.6cm}Định nghĩa các tuyến API cho quản lý người dùng:
                \begin{lstlisting}
    router.post("/register", registerUser);
    router.post("/login", loginUser);
    router.post("/logout", logoutUser);
    router.post("/update-avatar", authenticateToken, upload.single("avatar"), updateAvatar);
    router.post("/change-password", authenticateToken, changePassword);

    router.get('/verify-token', authenticateToken, (req, res) => {
        res.json({ valid: true });
    });
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{router.post("/register", registerUser)}: Tuyến POST để đăng ký người dùng mới.
                    \item \texttt{router.post("/login", loginUser)}: Tuyến POST để đăng nhập người dùng.
                    \item \texttt{router.post("/logout", logoutUser)}: Tuyến POST để đăng xuất người dùng.
                    \item \texttt{router.post("/update-avatar", authenticateToken, upload.single("avatar"), updateAvatar)}: Tuyến POST để cập nhật avatar, yêu cầu xác thực và tải tệp.
                    \item \texttt{router.post("/change-password", authenticateToken, changePassword)}: Tuyến POST để đổi mật khẩu, yêu cầu xác thực.
                    \item \texttt{router.get("/verify-token", authenticateToken, ...)}: Tuyến GET để xác minh token, trả về \texttt{\{ valid: true \}} nếu token hợp lệ.
                \end{itemize}

            \subsubsection{Export}
                \hspace*{0.6cm}Xuất router để sử dụng trong ứng dụng:
                \begin{lstlisting}
    export default router;
                \end{lstlisting}
                \begin{itemize}
                    \item Xuất \texttt{router} để tích hợp vào ứng dụng Express chính.
                \end{itemize}

            \subsubsection{Chức Năng Chính}
                \hspace*{0.6cm}Tệp định tuyến cung cấp các tuyến API để quản lý người dùng:
                \begin{itemize}
                    \item \textbf{Định Tuyến Yêu Cầu Người Dùng}: Xử lý các yêu cầu POST cho đăng ký, đăng nhập, đăng xuất, cập nhật avatar, và đổi mật khẩu; yêu cầu GET để xác minh token.
                    \item \textbf{Bảo Mật Yêu Cầu}: Sử dụng middleware \texttt{authenticateToken} để bảo vệ các tuyến \texttt{update-avatar}, \texttt{change-password}, và \texttt{verify-token}.
                    \item \textbf{Xử Lý Tệp Tải Lên}: Sử dụng middleware \texttt{upload.single("avatar")} để xử lý tệp avatar trong tuyến \texttt{update-avatar}.
                    \item \textbf{Tích Hợp Hàm Xử Lý}: Gọi các hàm từ \texttt{usersController} để thực hiện logic quản lý người dùng.
                    \item \textbf{Thiết Kế Mô-đun}: Sử dụng \texttt{express.Router} để tổ chức các tuyến API một cách độc lập, dễ bảo trì.
                \end{itemize}
    \section{MIDDLEWARE}
        \hspace*{0.6cm}Là nơi chứa các middleware dùng để:
        \begin{itemize}
            \item Xử lý trung gian: Thực hiện các tác vụ trước khi yêu cầu đến controller (như xác thực, xử lý file upload).
            \item Kiểm soát luồng yêu cầu: Kiểm tra, biến đổi hoặc chặn yêu cầu dựa trên điều kiện.
        \end{itemize}
        \subsection{auth}
            \hspace*{0.6cm}Middleware xác thực token người dùng, kiểm tra tính hợp lệ của token trong cookie và giải mã thông tin người dùng.
            \subsubsection{Import}
                \hspace*{0.6cm}Thư viện được nhập:
                \begin{lstlisting}
    import jwt from "jsonwebtoken";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{jwt}: Thư viện để xác minh và giải mã JSON Web Token.
                \end{itemize}

            \subsubsection{Hàm authenticateToken}
                \hspace*{0.6cm}Middleware xác minh token:
                \begin{lstlisting}
    export const authenticateToken = (req, res, next) => {
        const token = req.cookies.authToken;
        if (!token) {
            return res.status(401).json({ message: "Not logged in" });
        }

        jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
            if (err) {
                return res.status(403).json({ message: "Invalid token" });
            }
            req.user = user;
            next();
        });
    };
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{req}, \texttt{res}, \texttt{next}: Tham số chuẩn của middleware Express.
                    \item Lấy \texttt{token} từ cookie \texttt{authToken}.
                    \item Nếu không có token, trả về lỗi 401 với thông báo \texttt{"Not logged in"}.
                    \item Sử dụng \texttt{jwt.verify} để xác minh token với \texttt{JWT\_SECRET}.
                    \item Nếu token không hợp lệ, trả về lỗi 403 với thông báo \texttt{"Invalid token"}.
                    \item Nếu hợp lệ, gán thông tin người dùng vào \texttt{req.user} và gọi \texttt{next()} để chuyển tiếp yêu cầu.
                \end{itemize}

            \subsubsection{Export}
                \hspace*{0.6cm}Xuất middleware để sử dụng trong các tuyến API:
                \begin{lstlisting}
    export default authenticateToken;
                \end{lstlisting}
                \begin{itemize}
                    \item Xuất \texttt{authenticateToken} để tích hợp vào các tuyến API của ứng dụng Express.
                \end{itemize}

            \subsubsection{Chức Năng Chính}
                \hspace*{0.6cm}Middleware \texttt{authenticateToken} cung cấp xác thực cho các yêu cầu API:
                \begin{itemize}
                    \item \textbf{Xác Minh Token}: Kiểm tra sự tồn tại và tính hợp lệ của JWT trong cookie \texttt{authToken}.
                    \item \textbf{Bảo Vệ Tuyến API}: Từ chối các yêu cầu không có token (401) hoặc token không hợp lệ (403).
                    \item \textbf{Gán Thông Tin Người Dùng}: Thêm thông tin người dùng vào \texttt{req.user} nếu token hợp lệ.
                    \item \textbf{Tích Hợp Express}: Sử dụng cơ chế middleware để dễ dàng áp dụng cho các tuyến API cần xác thực.
                \end{itemize}
        \subsection{upload}
            \hspace*{0.6cm}Middleware xử lý tải tệp, sử dụng thư viện \texttt{multer} để quản lý việc tải lên tệp avatar của người dùng.
            \subsubsection{Import}
                \hspace*{0.6cm}Các thư viện được nhập:
                \begin{lstlisting}
    import multer from "multer";
    import path from "path";
    import { fileURLToPath } from "url";
    import fs from "fs";
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{multer}: Thư viện để xử lý tải lên tệp trong Express.
                    \item \texttt{path}: Xử lý đường dẫn tệp.
                    \item \texttt{fileURLToPath}: Chuyển URL mô-đun ES thành đường dẫn tệp.
                    \item \texttt{fs}: Quản lý hệ thống tệp (tạo thư mục, kiểm tra tệp).
                \end{itemize}

            \subsubsection{Biến Đường Dẫn}
                \hspace*{0.6cm}Định nghĩa đường dẫn tệp hiện tại:
                \begin{lstlisting}
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{\_\_filename}, \texttt{\_\_dirname}: Đường dẫn tệp hiện tại, hỗ trợ mô-đun ES.
                \end{itemize}

            \subsubsection{Cấu Hình Lưu Trữ}
                \hspace*{0.6cm}Cấu hình lưu trữ cho \texttt{multer}:
                \begin{lstlisting}
    const storage = multer.diskStorage({
        destination: (req, file, cb) => {
            const uploadDir = path.join(__dirname, "../upload/avatars");
            if (!fs.existsSync(uploadDir)) {
                fs.mkdirSync(uploadDir, { recursive: true });
            }
            cb(null, uploadDir);
        },
        filename: (req, file, cb) => {
            const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
            cb(null, uniqueSuffix + path.extname(file.originalname));
        },
    });
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{destination}: Tạo thư mục \texttt{upload/avatars} nếu chưa tồn tại, đặt đích lưu trữ là thư mục này.
                    \item \texttt{filename}: Tạo tên tệp duy nhất bằng thời gian hiện tại và số ngẫu nhiên, giữ nguyên phần mở rộng của tệp gốc.
                \end{itemize}

            \subsubsection{Cấu Hình Multer}
                \hspace*{0.6cm}Tạo middleware \texttt{upload} với \texttt{multer}:
                \begin{lstlisting}
    const upload = multer({
        storage,
        limits: { fileSize: 5 * 1024 * 1024 },
        fileFilter: (req, file, cb) => {
            const filetypes = /jpeg|jpg|png/;
            const extname = filetypes.test(path.extname(file.originalname).
            toLowerCase());
            const mimetype = filetypes.test(file.mimetype);
            if (extname && mimetype) {
                return cb(null, true);
            }
            cb(new Error("Only JPEG or PNG files are accepted"));
        },
    });
                \end{lstlisting}
                \begin{itemize}
                    \item \texttt{storage}: Sử dụng cấu hình lưu trữ đã định nghĩa.
                    \item \texttt{limits}: Giới hạn kích thước tệp tối đa 5MB (\texttt{5 * 1024 * 1024} byte).
                    \item \texttt{fileFilter}: Chỉ chấp nhận tệp JPEG hoặc PNG dựa trên phần mở rộng và loại MIME, trả về lỗi nếu không hợp lệ.
                \end{itemize}

            \subsubsection{Export}
                \hspace*{0.6cm}Xuất middleware để sử dụng trong các tuyến API:
                \begin{lstlisting}
    export default upload;
                \end{lstlisting}
                \begin{itemize}
                    \item Xuất \texttt{upload} để tích hợp vào các tuyến API Express, ví dụ: tuyến \texttt{update-avatar}.
                \end{itemize}

            \subsubsection{Chức Năng Chính}
                \hspace*{0.6cm}Middleware \texttt{upload} cung cấp xử lý tải lên tệp hình ảnh:
                \begin{itemize}
                    \item \textbf{Xử Lý Tệp Tải Lên}: Sử dụng \texttt{multer} để nhận và lưu tệp hình ảnh vào thư mục \texttt{upload/avatars}.
                    \item \textbf{Tạo Tên Tệp Duy Nhất}: Tạo tên tệp dựa trên thời gian và số ngẫu nhiên để tránh xung đột.
                    \item \textbf{Giới Hạn và Lọc Tệp}: Giới hạn kích thước tệp 5MB, chỉ chấp nhận định dạng JPEG hoặc PNG.
                    \item \textbf{Quản Lý Thư Mục}: Tự động tạo thư mục \texttt{upload/avatars} nếu chưa tồn tại.
                    \item \textbf{Tích Hợp Express}: Middleware dễ dàng áp dụng cho các tuyến API cần tải lên tệp.
                \end{itemize}
    \section{SERVER}
        \hspace*{0.6cm}Là Application Layer, xử lý logic và điều phối giữa Front-end và dbServer.
        \subsection{Import}
            \hspace*{0.6cm}Các thư viện và mô-đun được nhập:
            \begin{lstlisting}
    import express from "express";
    import dotenv from "dotenv";
    import deviceRoutes from "./routes/deviceRoutes.js";
    import userRoutes from "./routes/usersRoute.js";
    import { createRequire } from "module";
    import http from "http";
    import cookieParser from "cookie-parser";
    import path from "path";
    import { fileURLToPath } from "url";
            \end{lstlisting}
            \begin{itemize}
                \item \texttt{express}: Framework để tạo server và xử lý yêu cầu HTTP.
                \item \texttt{dotenv}: Tải biến môi trường từ tệp \texttt{.env}.
                \item \texttt{deviceRoutes}, \texttt{userRoutes}: Các tuyến API cho thiết bị và người dùng.
                \item \texttt{createRequire}: Hỗ trợ nhập CommonJS trong mô-đun ES.
                \item \texttt{http}: Tạo server HTTP cho Socket.IO.
                \item \texttt{cookieParser}: Xử lý cookie trong yêu cầu.
                \item \texttt{path}, \texttt{fileURLToPath}: Xử lý đường dẫn tệp.
            \end{itemize}

        \subsection{Biến Đường Dẫn}
            \hspace*{0.6cm}Định nghĩa đường dẫn tệp hiện tại:
            \begin{lstlisting}
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
            \end{lstlisting}
            \begin{itemize}
                \item \texttt{\_\_filename}, \texttt{\_\_dirname}: Đường dẫn tệp hiện tại, hỗ trợ mô-đun ES.
            \end{itemize}

        \subsection{Cấu Hình Môi Trường}
            \hspace*{0.6cm}Tải biến môi trường từ tệp \texttt{.env}:
            \begin{lstlisting}
    dotenv.config({ path: path.join(__dirname, "../.env") });
            \end{lstlisting}
            \begin{itemize}
                \item \texttt{dotenv.config}: Tải các biến môi trường từ tệp \texttt{.env} trong thư mục gốc.
            \end{itemize}

        \subsection{Khởi Tạo Server}
            \hspace*{0.6cm}Tạo ứng dụng Express và server HTTP:
            \begin{lstlisting}
    const app = express();
    const server = http.createServer(app);
            \end{lstlisting}
            \begin{itemize}
                \item \texttt{app}: Instance của \texttt{express} để xử lý yêu cầu HTTP.
                \item \texttt{server}: Server HTTP để hỗ trợ Socket.IO.
            \end{itemize}

        \subsection{Cấu Hình Socket.IO}
            \hspace*{0.6cm}Khởi tạo Socket.IO với CORS:
            \begin{lstlisting}
    const require = createRequire(import.meta.url);
    const socketIo = require("socket.io");

    const allowedOrigins = [
        "http://localhost:5173",
        "http://192.168.1.10:5173",
        "http://localhost:3000",
    ];

    const io = socketIo(server, {
        cors: {
            origin: allowedOrigins,
            methods: ["GET", "POST", "OPTIONS"],
            credentials: true,
        },
        pingTimeout: 60000,
        pingInterval: 25000,
    });
            \end{lstlisting}
            \begin{itemize}
                \item Nhập \texttt{socket.io} qua CommonJS vì mô-đun ES không hỗ trợ trực tiếp.
                \item \texttt{allowedOrigins}: Danh sách các nguồn được phép cho CORS.
                \item \texttt{io}: Instance Socket.IO với cấu hình CORS, thời gian chờ 60 giây, và kiểm tra kết nối mỗi 25 giây.
            \end{itemize}

        \subsection{Middleware}
            \hspace*{0.6cm}Cấu hình middleware cho ứng dụng:
            \begin{lstlisting}
    app.use((req, res, next) => {
        const origin = req.headers.origin;
        if (allowedOrigins.includes(origin)) {
            res.setHeader("Access-Control-Allow-Origin", origin);
            res.setHeader("Access-Control-Allow-Credentials", "true");
            res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
            res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
        }
        next();
    });

    app.use("/avatars", express.static(path.join(__dirname, "upload/avatars")));

    app.use(cookieParser());
    app.use(express.json());

    app.use((req, res, next) => {
        console.log(`Received request: ${req.method} ${req.url}`);
        next();
    });
            \end{lstlisting}
            \begin{itemize}
                \item CORS middleware: Cho phép các nguồn trong \texttt{allowedOrigins} với phương thức GET, POST, OPTIONS và hỗ trợ cookie.
                \item Phục vụ tệp tĩnh: Phục vụ tệp từ thư mục \texttt{upload/avatars} tại tuyến \texttt{/avatars}.
                \item \texttt{cookieParser}: Xử lý cookie trong yêu cầu.
                \item \texttt{express.json}: Phân tích dữ liệu JSON từ yêu cầu.
                \item Logging middleware: Ghi log phương thức và URL của mỗi yêu cầu.
            \end{itemize}

        \subsection{Định Tuyến}
            \hspace*{0.6cm}Tích hợp các tuyến API:
            \begin{lstlisting}
    app.use("/api/users", userRoutes);
    app.use("/api/devices", deviceRoutes);
            \end{lstlisting}
            \begin{itemize}
                \item \texttt{userRoutes}: Xử lý các API liên quan đến người dùng tại \texttt{/api/users}.
                \item \texttt{deviceRoutes}: Xử lý các API liên quan đến thiết bị tại \texttt{/api/devices}.
            \end{itemize}

        \subsection{Tuyến Gốc}
            \hspace*{0.6cm}Định nghĩa tuyến gốc:
            \begin{lstlisting}
    app.get("/", (req, res) => {
        res.send("Backend is running");
    });
            \end{lstlisting}
            \begin{itemize}
                \item Trả về thông báo "Backend is running" cho yêu cầu GET tại \texttt{/}. Lưu ý: Emoji đã được giữ nguyên vì báo cáo không yêu cầu thay đổi chuỗi này.
            \end{itemize}

        \subsection{Xử Lý Socket.IO}
            \hspace*{0.6cm}Xử lý các sự kiện Socket.IO:
            \begin{lstlisting}
    io.on("connection", (socket) => {
        console.log("Client connected:", socket.id, socket.handshake.query);

        socket.on("message", (msg) => {
            console.log("Received message:", msg);
        });

        socket.on("Value", (data) => {
            console.log("Received value:", data);
        });

        socket.on("disconnect", (reason) => {
            console.log("Client disconnected:", socket.id, "Reason:", reason);
        });
    });
            \end{lstlisting}
            \begin{itemize}
                \item Lắng nghe sự kiện \texttt{connection}: Ghi log khi client kết nối.
                \item Lắng nghe \texttt{message} và \texttt{Value}: Ghi log dữ liệu nhận được.
                \item Lắng nghe \texttt{disconnect}: Ghi log khi client ngắt kết nối và lý do.
            \end{itemize}

        \subsection{Khởi Động Server}
            \hspace*{0.6cm}Khởi động server trên cổng được chỉ định:
            \begin{lstlisting}
    const PORT = process.env.PORT || 5000;
    server.listen(PORT, "0.0.0.0", () => {
        console.log(`Server running at http://0.0.0.0:${PORT}`);
    });
            \end{lstlisting}
            \begin{itemize}
                \item \texttt{PORT}: Lấy từ biến môi trường hoặc mặc định 5000.
                \item \texttt{server.listen}: Khởi động server trên tất cả các giao diện mạng (\texttt{0.0.0.0}).
            \end{itemize}

        \subsection{Chức Năng Chính}
            \hspace*{0.6cm}Tệp khởi tạo ứng dụng Express cung cấp nền tảng cho server:
            \begin{itemize}
                \item \textbf{Xử Lý Yêu Cầu HTTP}: Tích hợp Express để xử lý các yêu cầu qua các tuyến API \texttt{userRoutes} và \texttt{deviceRoutes}.
                \item \textbf{Giao Tiếp Thời Gian Thực}: Sử dụng Socket.IO để xử lý kết nối, tin nhắn, và sự kiện giá trị từ client.
                \item \textbf{Phục Vụ Tệp Tĩnh}: Phục vụ hình ảnh avatar từ thư mục \texttt{upload/avatars}.
                \item \textbf{Cấu Hình CORS}: Cho phép các nguồn được chỉ định truy cập API với hỗ trợ cookie.
                \item \textbf{Middleware}: Áp dụng \texttt{cookieParser}, \texttt{express.json}, và logging để xử lý yêu cầu hiệu quả.
            \end{itemize}

